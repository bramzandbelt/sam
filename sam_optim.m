function varargout = sam_optim(SAM)
% Optimizes stochastic accumulator model to account for observations
%  
% DESCRIPTION 
% <Describe more extensively what this function does> 
%  
% SYNTAX 
% SAM_OPTIM; 
%  
% EXAMPLES 
%  
%  
% REFERENCES 
%  
% ......................................................................... 
% Bram Zandbelt, bramzandbelt@gmail.com 
% $Created : Sat 21 Sep 2013 12:53:48 CDT by bram 
% $Modified: Sat 21 Sep 2013 19:40:18 CDT by bram

 
% CONTENTS 
% 1.PROCESS INPUTS AND SPECIFY VARIABLES 
%   1.1.Process inputs
%   1.2. Pre-allocate empty arrays
% 2.SPECIFY PRECURSOR AND PARAMETER-INDEPENDENT MODEL MATRICES
% 3.CHARACTERIZE OBSERVED DATA
%   3.1. Organize observations
%   3.2. Compute response time bin statistics
% 4.OPTIMIZE MODEL
%   4.1.Seed the random number generator
%   4.2.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% 1. PROCESS INPUTS AND SPECIFY VARIABLES
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
 
% 1.1. Process inputs
% ========================================================================= 

% Scope of the simulation
simScope    = SAM.sim.scope;

% Solver type
solverType  = SAM.optim.solverType;

% Solver options
solverOpts  = SAM.optim.solverOpts;

% Starting values
% ---------------------------------------------------------------------
X0          = SAM.optim.X0;


% Cost function 
% ---------------------------------------------------------------------
costFun     = SAM.optim.costFun;

% Cumulative probabilities for which to compute quantiles
cumProb     = SAM.optim.cumProb;

% Minimum bin size (in number of trials per bin)
minBinSize  = SAM.optim.minBinSize;

% Logging
% ---------------------------------------------------------------------

% Iteration log file
iterLogFile = SAM.optim.iterLogFile;

% Iteration lof frequency
iterLogFreq = SAM.optim.iterLogFreq;

% Final log file
finalLogFile = SAM.optim.finalLogFile;

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% 2. OPTIMIZE MODEL
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

% 2.1. Switch between solvers
% =========================================================================

switch lower(solverType)
  % 2.1.1. Simplex
  % -----------------------------------------------------------------------
  case 'fminsearchbnd'
    
    history = nan(solverOpts.MaxIter + 1,numel(X0) + 1);
    
    solverOpts.OutputFcn        = @myoutput;
    
    [X, ...
     fVal, ...
     exitFlag, ...
     solverOutput] ...
     ...
     = fminsearchbnd ...
     (@(X)  ...
     costFun ...
     (X, ...
      SAM, ...
      obsOptimData, ...
      prdOptimData), ...
      ...
      X0, ...
      solverOpts);
    
      % Save the final log file
      save(finalLogFile,'X','fVal','exitFlag','solverOutput','history');
      
      % Remove iteration log file (history is also saved in final log file)
      delete(iterLogFile);
      
      varargout{1} = X;
      varargout{2} = fVal;
      varargout{3} = exitFlag;
      varargout{4} = solverOutput;
      varargout{5} = history;
  
  case 'fminsearchcon'
    
    history = nan(solverOpts.MaxIter + 1,numel(X0) + 1);
    
    solverOpts.OutputFcn        = @myoutput;
    
    tS = tic;
    
    [X, ...
     fVal, ...
     exitFlag, ...
     solverOutput] ...
     ...
     = fminsearchcon ...
     (@(X)  ...
     costFun ...
     (X, ...
      SAM, ...
      obsOptimData, ...
      prdOptimData), ...
      ...
      X0, ...
      solverOpts);
    
    tElapse = toc(tS);
    
      % Remove unused lines (containing only NaNs)
      iFirstNanLine = find(all(isnan(history),2),1,'first');
      history = history(1:iFirstNanLine-1,:);
    
      % Save the final log file
      save(finalLogFile,'X','fVal','exitFlag','solverOutput','history','tElapse');
      
      % Remove iteration log file (history is also saved in final log file)
      delete(iterLogFile);
      
      varargout{1} = X;
      varargout{2} = fVal;
      varargout{3} = exitFlag;
      varargout{4} = solverOutput;
      varargout{5} = history;
      
  case 'fmincon'
    
    history = nan(solverOpts.MaxIter + 1,numel(X0) + 1);
    
    solverOpts.OutputFcn        = @myoutput;
    
    [X, ...
     fVal, ...
     exitFlag, ...
     solverOutput] ...
     ...
     = fmincon ...
     (@(X)  ...
     costFun ...
     (X, ...
      SAM, ...
      obsOptimData, ...
      prdOptimData, ...
      VCor, ...
      VIncor, ...
      S, ...
      terminate, ...
      blockInput, ...
      latInhib), ...
      ...
      X0, ...
      linConA, ...
      linConB, ...
      [], ...
      [], ...
      LB, ...
      UB, ...
      nonLinCon, ...
      solverOpts);
    
    % Save the final log file
    save(finalLogFile,'X','fVal','exitFlag','solverOutput','history');

    % Remove iteration log file (history is also saved in final log file)
    delete(iterLogFile);

    varargout{1} = X;
    varargout{2} = fVal;
    varargout{3} = exitFlag;
    varargout{4} = solverOutput;
    varargout{5} = history;

      
  % 2.1.2. Differential evolution
  % -----------------------------------------------------------------------
  case 'de'
  
  % 2.1.3. Genetic algorithm
  % -----------------------------------------------------------------------
  case 'ga'

    nX = numel(LB);
    
    [X, ...
     fVal, ...
     exitFlag, ...
     solverOutput, ...
     pop, ...
     cost] = ga(@(X)  costFun ...
                     (X, ...
                      SAM, ...
                      obsOptimData, ...
                      prdOptimData, ...
                      VCor, ...
                      VIncor, ...
                      S, ...
                      terminate, ...
                      blockInput, ...
                      latInhib), ...
                      ...
                      nX, ...
                      linConA, ...
                      linConB, ...
                      [], ...
                      [], ...
                      LB, ...
                      UB, ...
                      nonLinCon, ...
                      solverOpts);

  % 2.1.4. Simulated annealing
  % -----------------------------------------------------------------------
  case 'sa'

    [X, ...
     fVal, ...
     exitFlag, ...
     solverOutput] = simulannealbnd(@(X)  costFun(simGoal, ...
                                                  X0, ...
                                                  STATE, ...
                                                  obs, ...
                                                  prd, ...
                                                  SAM, ...
                                                  nSim, ...
                                                  simFun, ...
                                                  simScope, ...
                                                  VCor, ...
                                                  VIncor, ...
                                                  S, ...
                                                  terminate, ...
                                                  blockInput, ...
                                                  latInhib, ...
                                                  doPlot), ...
                                                  ...
                                                  X0, ...
                                                  LB, ...
                                                  UB, ...
                                                  solver.options);
end

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% 3. OUTPUT
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

SAM.estim.X             = X;
SAM.estim.fVal          = fVal;
SAM.estim.exitFlag      = exitFlag;
SAM.estim.solverOutput  = solverOutput;


function stop = myoutput(x,optimvalues,state);
  stop = false;
  if state == 'iter'
    history(optimvalues.iteration + 1,:) = [optimvalues.fval,x];
    
    % Save the iteration log file if
    if ismultiple(optimvalues.iteration,iterLogFreq)
      save(iterLogFile,'history');
    end
  end
end

  function out = ismultiple(iter,freq)
    out = freq*round(double(iter)/freq) == iter;
  end
end
